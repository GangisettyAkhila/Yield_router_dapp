#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 8
    bytecblock "" "staked_amt" "stake_time" "platform" "stake_count" 0x151f7c75 "apy_" "game_credits" "stake_credits" "platform_list"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/yield_router/contract.py:16-17
    // # List of supported platforms (for iteration)
    // self.platform_list = (
    bytec 9 // "platform_list"
    pushbytes 0x0006000f0018000754696e796d616e00074d657373696e61000c466f6c6b7346696e616e6365
    // smart_contracts/yield_router/contract.py:16-21
    //         # List of supported platforms (for iteration)
    //         self.platform_list = (
    //     String("Tinyman"),
    //     String("Messina"),
    //     String("FolksFinance")
    // )
    app_global_put

main_after_if_else@2:
    // smart_contracts/yield_router/contract.py:3
    // class YieldRouterContract(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x0642ff90 0x5eb259de 0x9be35335 0x1d07469e 0xbc76d9bb 0xc7e8c8e1 0x5cd41c93 // method "stake(pay,address,address,uint64,uint64,string)void", method "unstake(address,uint64,uint64)void", method "update_platform_apy(string,uint64)void", method "get_user_tracking(address)(uint64,uint64,string,uint64,uint64,uint64)", method "calculate_rewards(address,uint64)uint64", method "claim_yield(address,uint64)(uint64,uint64)", method "get_recommended_platform(address)string"
    txna ApplicationArgs 0
    match stake unstake update_platform_apy get_user_tracking calculate_rewards claim_yield get_recommended_platform
    err

main___algopy_default_create@16:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.yield_router.contract.YieldRouterContract.stake[routing]() -> void:
stake:
    // smart_contracts/yield_router/contract.py:23
    // @arc4.abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/yield_router/contract.py:33
    // assert payment.receiver == contract_address, "Payment must go to contract"
    dig 5
    gtxns Receiver
    uncover 5
    ==
    assert // Payment must go to contract
    // smart_contracts/yield_router/contract.py:34
    // assert payment.amount == amount, "Payment amount must match stake amount"
    uncover 4
    gtxns Amount
    dig 3
    ==
    assert // Payment amount must match stake amount
    // smart_contracts/yield_router/contract.py:35
    // assert amount > UInt64(0), "Staking amount must be greater than zero"
    dig 2
    assert // Staking amount must be greater than zero
    // smart_contracts/yield_router/contract.py:37
    // previous = self.staked_amount.get(for_account, default=UInt64(0))
    dig 3
    intc_0 // 0
    bytec_1 // "staked_amt"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:38
    // self.staked_amount[for_account] = previous + amount
    uncover 3
    +
    dig 3
    bytec_1 // "staked_amt"
    uncover 2
    app_local_put
    // smart_contracts/yield_router/contract.py:39
    // self.staking_timestamp[for_account] = timestamp
    dig 2
    bytec_2 // "stake_time"
    uncover 3
    app_local_put
    // smart_contracts/yield_router/contract.py:40
    // self.last_platform[for_account] = platform
    dig 1
    bytec_3 // "platform"
    uncover 2
    app_local_put
    // smart_contracts/yield_router/contract.py:41
    // self.total_stake_count[for_account] = self.total_stake_count.get(for_account, default=UInt64(0)) + UInt64(1)
    dup
    intc_0 // 0
    bytec 4 // "stake_count"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    intc_1 // 1
    +
    bytec 4 // "stake_count"
    swap
    app_local_put
    // smart_contracts/yield_router/contract.py:23
    // @arc4.abimethod
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.unstake[routing]() -> void:
unstake:
    // smart_contracts/yield_router/contract.py:43
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/yield_router/contract.py:45
    // assert amount > UInt64(0), "Unstaking amount must be greater than zero"
    dig 1
    assert // Unstaking amount must be greater than zero
    // smart_contracts/yield_router/contract.py:46
    // prev = self.staked_amount.get(for_account, default=UInt64(0))
    dig 2
    intc_0 // 0
    bytec_1 // "staked_amt"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:47
    // assert amount <= prev, "Cannot unstake more than currently staked"
    dig 2
    dig 1
    <=
    assert // Cannot unstake more than currently staked
    // smart_contracts/yield_router/contract.py:48
    // self.staked_amount[for_account] = prev - amount
    uncover 2
    -
    dig 2
    bytec_1 // "staked_amt"
    uncover 2
    app_local_put
    // smart_contracts/yield_router/contract.py:49
    // self.staking_timestamp[for_account] = timestamp
    bytec_2 // "stake_time"
    swap
    app_local_put
    // smart_contracts/yield_router/contract.py:43
    // @arc4.abimethod
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.update_platform_apy[routing]() -> void:
update_platform_apy:
    // smart_contracts/yield_router/contract.py:51
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/yield_router/contract.py:53-54
    // # Ideally, this should be restricted to admin
    // self.platform_apys[platform] = apy
    bytec 6 // "apy_"
    uncover 2
    concat
    swap
    itob
    box_put
    // smart_contracts/yield_router/contract.py:51
    // @arc4.abimethod
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.get_user_tracking[routing]() -> void:
get_user_tracking:
    // smart_contracts/yield_router/contract.py:56
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/yield_router/contract.py:59
    // self.staked_amount.get(for_account, default=UInt64(0)),
    dup
    intc_0 // 0
    bytec_1 // "staked_amt"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:60
    // self.staking_timestamp.get(for_account, default=UInt64(0)),
    dig 1
    intc_0 // 0
    bytec_2 // "stake_time"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:61
    // self.last_platform.get(for_account, default=String("")),
    dig 2
    intc_0 // 0
    bytec_3 // "platform"
    app_local_get_ex
    bytec_0 // ""
    cover 2
    select
    // smart_contracts/yield_router/contract.py:62
    // self.total_stake_count.get(for_account, default=UInt64(0)),
    dig 3
    intc_0 // 0
    bytec 4 // "stake_count"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:63
    // self.game_credits.get(for_account, default=UInt64(0)),
    dig 4
    intc_0 // 0
    bytec 7 // "game_credits"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:64
    // self.stake_credits.get(for_account, default=UInt64(0)),
    uncover 5
    intc_0 // 0
    bytec 8 // "stake_credits"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:56
    // @arc4.abimethod
    uncover 5
    itob
    uncover 5
    itob
    concat
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    swap
    pushbytes 0x002a
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards[routing]() -> void:
calculate_rewards:
    // smart_contracts/yield_router/contract.py:67
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.claim_yield[routing]() -> void:
claim_yield:
    // smart_contracts/yield_router/contract.py:79
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    bytec_0 // ""
    cover 2
    bytec_0 // ""
    cover 2
    // smart_contracts/yield_router/contract.py:81
    // reward = self.calculate_rewards(for_account, current_time)
    callsub smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards
    dup
    // smart_contracts/yield_router/contract.py:82
    // if reward > UInt64(0):
    bz claim_yield_after_if_else@3
    // smart_contracts/yield_router/contract.py:83-84
    // # Mint GameCredits and StakeCredits from yield (e.g., 50% each)
    // game_credits_mint = reward // UInt64(2)
    dupn 2
    pushint 2 // 2
    /
    dup
    bury 4
    // smart_contracts/yield_router/contract.py:85
    // stake_credits_mint = reward - game_credits_mint
    swap
    dig 1
    -
    dup
    cover 2
    bury 5
    // smart_contracts/yield_router/contract.py:86
    // self.game_credits[for_account] = self.game_credits.get(for_account, default=UInt64(0)) + game_credits_mint
    dig 6
    dup
    cover 2
    intc_0 // 0
    bytec 7 // "game_credits"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    +
    dig 1
    bytec 7 // "game_credits"
    uncover 2
    app_local_put
    // smart_contracts/yield_router/contract.py:87
    // self.stake_credits[for_account] = self.stake_credits.get(for_account, default=UInt64(0)) + stake_credits_mint
    dup
    intc_0 // 0
    bytec 8 // "stake_credits"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    uncover 2
    +
    dig 1
    bytec 8 // "stake_credits"
    uncover 2
    app_local_put
    // smart_contracts/yield_router/contract.py:88-89
    // # Reset staking timestamp to current time for next reward calculation
    // self.staking_timestamp[for_account] = current_time
    bytec_2 // "stake_time"
    dig 5
    app_local_put

claim_yield_after_if_else@3:
    // smart_contracts/yield_router/contract.py:79
    // @arc4.abimethod
    dig 1
    itob
    dig 3
    itob
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.yield_router.contract.YieldRouterContract.get_recommended_platform[routing]() -> void:
get_recommended_platform:
    bytec_0 // ""
    // smart_contracts/yield_router/contract.py:92
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/yield_router/contract.py:94
    // last_platform = self.last_platform.get(for_account, default=String(""))
    intc_0 // 0
    bytec_3 // "platform"
    app_local_get_ex
    bytec_0 // ""
    cover 2
    select
    // smart_contracts/yield_router/contract.py:95
    // best_platform = String("")
    bytec_0 // ""
    // smart_contracts/yield_router/contract.py:96
    // highest_score = UInt64(0)
    intc_0 // 0
    // smart_contracts/yield_router/contract.py:98
    // for platform in self.platform_list:
    dup
    bytec 9 // "platform_list"
    app_global_get_ex
    assert // check self.platform_list exists
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    cover 2
    dig 1
    pushint 4 // 4
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    cover 2
    dig 1
    len
    substring3
    extract 2 0
    intc_0 // 0

get_recommended_platform_for_body@2:
    // smart_contracts/yield_router/contract.py:99
    // apy = self.platform_apys.get(platform, default=UInt64(0))
    bytec 6 // "apy_"
    dig 4
    dup
    cover 2
    concat
    box_get
    swap
    btoi
    intc_0 // 0
    swap
    uncover 2
    select
    swap
    // smart_contracts/yield_router/contract.py:102-103
    // # Bonus: reward user familiarity with platforms they've used before
    // if platform == last_platform:
    dig 8
    ==
    bnz get_recommended_platform_if_body@3
    bury 9

get_recommended_platform_after_if_else@4:
    // smart_contracts/yield_router/contract.py:105-106
    // # Add tiny bonus based on loyalty
    // loyalty = self.total_stake_count.get(for_account, default=UInt64(0))
    dig 7
    intc_0 // 0
    bytec 4 // "stake_count"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:107
    // score = score + (loyalty * UInt64(10))
    pushint 10 // 10
    *
    dig 9
    +
    dup
    bury 10
    // smart_contracts/yield_router/contract.py:109
    // if score > highest_score:
    dig 5
    >
    bz get_recommended_platform_after_if_else@6
    dig 3
    bury 6
    dig 8
    bury 5

get_recommended_platform_after_if_else@6:
    // smart_contracts/yield_router/contract.py:98
    // for platform in self.platform_list:
    dup
    switch get_recommended_platform_for_header_1@8 get_recommended_platform_for_header_2@9
    // smart_contracts/yield_router/contract.py:92
    // @arc4.abimethod
    dig 5
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_recommended_platform_for_header_2@9:
    pushint 2 // 2
    bury 1
    dig 1
    bury 4
    b get_recommended_platform_for_body@2

get_recommended_platform_for_header_1@8:
    intc_1 // 1
    bury 1
    dig 2
    bury 4
    b get_recommended_platform_for_body@2

get_recommended_platform_if_body@3:
    // smart_contracts/yield_router/contract.py:104
    // score = score // UInt64(2)  # reduce weight to encourage diversity
    pushint 2 // 2
    /
    bury 9
    b get_recommended_platform_after_if_else@4


// smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards(for_account: bytes, current_time: uint64) -> uint64:
smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards:
    // smart_contracts/yield_router/contract.py:67-68
    // @arc4.abimethod
    // def calculate_rewards(self, for_account: Account, current_time: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/yield_router/contract.py:69
    // stake_time = self.staking_timestamp.get(for_account, default=UInt64(0))
    frame_dig -2
    intc_0 // 0
    bytec_2 // "stake_time"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    dup
    // smart_contracts/yield_router/contract.py:70
    // if stake_time == UInt64(0):
    bnz smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards_after_if_else@2
    // smart_contracts/yield_router/contract.py:71
    // return UInt64(0)
    intc_0 // 0
    swap
    retsub

smart_contracts.yield_router.contract.YieldRouterContract.calculate_rewards_after_if_else@2:
    // smart_contracts/yield_router/contract.py:72
    // time_diff = current_time - stake_time
    frame_dig -1
    frame_dig 0
    -
    // smart_contracts/yield_router/contract.py:73
    // staked = self.staked_amount.get(for_account, default=UInt64(0))
    frame_dig -2
    intc_0 // 0
    bytec_1 // "staked_amt"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/yield_router/contract.py:74
    // platform = self.last_platform.get(for_account, default=String(""))
    frame_dig -2
    intc_0 // 0
    bytec_3 // "platform"
    app_local_get_ex
    bytec_0 // ""
    cover 2
    select
    // smart_contracts/yield_router/contract.py:75
    // apy = self.platform_apys.get(platform, default=UInt64(0))
    bytec 6 // "apy_"
    swap
    concat
    box_get
    swap
    btoi
    intc_0 // 0
    swap
    uncover 2
    select
    // smart_contracts/yield_router/contract.py:76
    // reward = (staked * apy * time_diff) // (365 * 24 * 3600 * 10000)
    *
    *
    pushint 315360000000 // 315360000000
    /
    // smart_contracts/yield_router/contract.py:77
    // return reward
    swap
    retsub
